<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate Guide to Factory and Strategy Patterns</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s ease;
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0;
        }
        .collapsible-content.expanded {
            max-height: none; /* Removed fixed height for dynamic content */
            overflow: auto; /* Added vertical scrollbar for long content */
            padding: 1rem;
        }
        .collapsible-header::after {
            content: '+';
            font-weight: bold;
            float: right;
            transition: transform 0.3s ease-out;
        }
        .collapsible-header.expanded::after {
            content: '-';
        }
        .collapsible-header.expanded {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }
        .collapsible-content.expanded {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 p-4 sm:p-8">
    <div class="max-w-6xl mx-auto space-y-12">
        <!-- Main Title -->
        <header class="text-center">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-white leading-tight mb-2">
                <span class="text-yellow-400">üè≠üß©</span> The Ultimate Guide to Factory and Strategy Patterns
            </h1>
            <p class="text-lg text-gray-400 max-w-2xl mx-auto">
                Welcome, future software architect! This guide will demystify two of the most essential design patterns you'll encounter. We'll break down the Factory and Strategy patterns so you can master them for your projects and for any interview. Let's dive in!
            </p>
        </header>

        <hr class="border-gray-700">

        <!-- Factory Pattern Section -->
        <section class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-xl space-y-6">
            <h2 class="text-3xl font-bold text-yellow-400 flex items-center gap-2">
                The Factory Pattern üè≠
            </h2>
            <img class="w-full h-auto rounded-lg shadow-lg" src="http://googleusercontent.com/image_generation_content/1" alt="A factory floor with machines producing various documents like PDF, Word, and HTML.">

            <div class="space-y-4">
                <!-- Explanation -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Explanation
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <p class="text-gray-300 leading-relaxed">
                            The Factory pattern is a <span class="font-semibold text-white">creational pattern</span>. Its main job is to handle the messy details of creating objects, so you don't have to. It provides a single, unified interface for creating objects. This allows the code that uses the objects (the client) to be completely unaware of the specific type of object it's getting. The magic word is <span class="font-semibold text-white">decoupling</span>. The client is decoupled from the concrete product classes, making your code more flexible and easier to maintain.
                        </p>
                    </div>
                </div>

                <!-- Real-Life Analogy -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Real-Life Analogy
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <p class="text-gray-300 leading-relaxed">
                            Imagine a software application that can export documents in different formats, such as PDF, Word, or HTML. When you click the "Export" button, you simply select the format you want. You don't have to worry about the specific complex steps of generating a .pdf file versus a .docx file. The application uses a <span class="font-semibold text-white">Document Factory</span> behind the scenes. This factory takes your request ("PDF") and internally creates the correct type of document object. You, the client, simply receive the finished document object that you can use, without needing to know the specifics of its creation.
                        </p>
                    </div>
                </div>

                <!-- C++ Program Example -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        C++ Program Example
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <pre class="bg-gray-900 text-gray-300 p-4 rounded-lg overflow-x-auto text-sm sm:text-base"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;

// 1. Product Interface: The common interface for all products (documents).
class Document {
public:
    virtual ~Document() = default;
    virtual void exportContent() const = 0;
};

// 2. Concrete Products: Specific types of documents.
class PdfDocument : public Document {
public:
    void exportContent() const override {
        std::cout &lt;&lt; "Creating a PDF document...\n";
    }
};

class WordDocument : public Document {
public:
    void exportContent() const override {
        std::cout &lt;&lt; "Creating a Word document...\n";
    }
};

class HtmlDocument : public Document {
public:
    void exportContent() const override {
        std::cout &lt;&lt; "Creating an HTML document...\n";
    }
};

// 3. The Factory: A class with a method for creating products.
class DocumentFactory {
public:
    static std::unique_ptr&lt;Document&gt; createDocument(const std::string&amp; type) {
        if (type == "pdf") {
            return std::make_unique&lt;PdfDocument&gt;();
        } else if (type == "word") {
            return std::make_unique&lt;WordDocument&gt;();
        } else if (type == "html") {
            return std::make_unique&lt;HtmlDocument&gt;();
        } else {
            std::cerr &lt;&lt; "Error: Unknown document type '" &lt;&lt; type &lt;&lt; "'\n";
            return nullptr;
        }
    }
};

// Main function to demonstrate the Factory Pattern.
int main() {
    std::cout &lt;&lt; "--- Document Factory Demo ---\n";
    
    // The client code requests a PDF document from the factory.
    std::unique_ptr&lt;Document&gt; pdfDoc = DocumentFactory::createDocument("pdf");
    if (pdfDoc) {
        pdfDoc-&gt;exportContent();
    }

    // The client code requests a Word document from the factory.
    std::unique_ptr&lt;Document&gt; wordDoc = DocumentFactory::createDocument("word");
    if (wordDoc) {
        wordDoc-&gt;exportContent();
    }

    // The factory handles an invalid request gracefully.
    std::unique_ptr&lt;Document&gt; invalidDoc = DocumentFactory::createDocument("text");
    if (!invalidDoc) {
        std::cout &lt;&lt; "Failed to create a document of type 'text'. (Expected behavior)\n";
    }

    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- Real-Life Use Cases -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Real-Life Use Cases
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li><span class="font-semibold text-white">GUI Frameworks:</span> A `WidgetFactory` might create different types of buttons (`WindowsButton`, `MacButton`) based on the operating system.</li>
                            <li><span class="font-semibold text-white">Game Development:</span> A `EnemyFactory` could create various enemies (`Zombie`, `Alien`, `Dragon`) based on the current level or game state.</li>
                            <li><span class="font-semibold text-white">Database Management:</span> A `DatabaseFactory` might provide connections to different databases (`PostgresConnection`, `MySqlConnection`) based on a configuration setting.</li>
                        </ul>
                    </div>
                </div>

                <!-- When to Use -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        When to Use the Factory Pattern
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li>When your code needs to create objects of a class hierarchy but doesn't know in advance which concrete class to instantiate.</li>
                            <li>When you want to provide a single, unified way to create objects without exposing the complex creation logic to the client.</li>
                            <li>When you need to easily add new object types in the future without changing the code that uses those objects.</li>
                        </ul>
                    </div>
                </div>

                <!-- Advantage and Disadvantage -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Advantage and Disadvantage
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <div class="overflow-x-auto">
                            <table class="w-full text-left table-auto border-collapse border border-gray-600 rounded-lg">
                                <thead>
                                    <tr class="bg-gray-900 text-white">
                                        <th class="p-3 border-b border-gray-600">‚úÖ Advantages</th>
                                        <th class="p-3 border-b border-gray-600">‚ùå Disadvantages</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="border-b border-gray-600">
                                        <td class="p-3">Loose Coupling: The client code is simplified because it's not tied to a specific product implementation.</td>
                                        <td class="p-3">Can introduce more classes and a more complex hierarchy.</td>
                                    </tr>
                                    <tr class="border-b border-gray-600">
                                        <td class="p-3">Encapsulation: Creation logic is centralized in one place.</td>
                                        <td class="p-3">The factory might become a "God object" if it handles too many unrelated products.</td>
                                    </tr>
                                    <tr class="border-b border-gray-600">
                                        <td class="p-3">Extensibility: Easily add new products without changing client code.</td>
                                        <td class="p-3">It can be over-engineered for very simple object creation.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <hr class="border-gray-700">

        <!-- Strategy Pattern Section -->
        <section class="bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-xl space-y-6">
            <h2 class="text-3xl font-bold text-blue-400 flex items-center gap-2">
                The Strategy Pattern üß©
            </h2>
            
            <div class="space-y-4">
                <!-- Explanation -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Explanation
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <p class="text-gray-300 leading-relaxed">
                            The Strategy pattern is a <span class="font-semibold text-white">behavioral pattern</span>. Its goal is to take a specific action or algorithm and separate it from the class that uses it. This allows you to select an algorithm at runtime and use it to perform a task. The class that needs the behavior (the Context) holds a reference to an algorithm object (the Strategy) and delegates the work to it. This means the Context doesn't need to know the details of the algorithm; it just knows how to use it through a common interface.
                        </p>
                    </div>
                </div>

                <!-- Real-Life Analogy -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Real-Life Analogy
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <p class="text-gray-300 leading-relaxed">
                            Think about a GPS navigation app on your phone. When you want directions, the app (the Context) needs to find the best route. But "best" depends on how you're traveling.
                            <ul class="list-disc list-inside mt-2 space-y-1">
                                <li>If you choose "car," the app uses a <span class="font-semibold text-white">CarRouteStrategy</span> that prioritizes highways and speed.</li>
                                <li>If you choose "bike," it uses a <span class="font-semibold text-white">BikeRouteStrategy</span> that prefers bike lanes and avoids heavy traffic.</li>
                                <li>If you choose "walk," it uses a <span class="font-semibold text-white">WalkingRouteStrategy</span> that finds sidewalks and footpaths.</li>
                            </ul>
                            The core navigation app doesn't have a giant `if-else` statement to figure out the route for each mode. Instead, it simply swaps the Strategy object it's using. You can change your travel method on the fly, and the app instantly uses a new algorithm without its core code ever changing.
                        </p>
                    </div>
                </div>

                <!-- C++ Program Example -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        C++ Program Example
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <pre class="bg-gray-900 text-gray-300 p-4 rounded-lg overflow-x-auto text-sm sm:text-base"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;

// 1. Strategy Interface: The common interface for all algorithms (routing).
class RouteStrategy {
public:
    virtual ~RouteStrategy() = default;
    virtual void buildRoute(const std::string&amp; start, const std::string&amp; end) const = 0;
};

// 2. Concrete Strategies: Specific routing algorithms.
class CarRouteStrategy : public RouteStrategy {
public:
    void buildRoute(const std::string&amp; start, const std::string&amp; end) const override {
        std::cout &lt;&lt; "Calculating car route from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; ": Prioritizing speed and highways.\n";
    }
};

class BikeRouteStrategy : public RouteStrategy {
public:
    void buildRoute(const std::string&amp; start, const std::string&amp; end) const override {
        std::cout &lt;&lt; "Calculating bike route from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; ": Using bike lanes and scenic paths.\n";
    }
};

class WalkingRouteStrategy : public RouteStrategy {
public:
    void buildRoute(const std::string&amp; start, const std::string&amp; end) const override {
        std::cout &lt;&lt; "Calculating walking route from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; ": Focusing on sidewalks and pedestrian-friendly streets.\n";
    }
};

// 3. Context: The class that uses a strategy.
class Navigator {
public:
    explicit Navigator(std::unique_ptr&lt;RouteStrategy&gt; strategy)
        : strategy_(std::move(strategy)) {}

    void setStrategy(std::unique_ptr&lt;RouteStrategy&gt; strategy) {
        strategy_ = std::move(strategy);
    }

    void findRoute(const std::string&amp; start, const std::string&amp; end) const {
        if (strategy_) {
            strategy_-&gt;buildRoute(start, end);
        } else {
            std::cerr &lt;&lt; "Error: No routing strategy set.\n";
        }
    }
private:
    std::unique_ptr&lt;RouteStrategy&gt; strategy_;
};

// Main function to demonstrate the Strategy Pattern.
int main() {
    std::cout &lt;&lt; "--- Navigation App Demo ---\n";
    
    std::string startLocation = "Home";
    std::string endLocation = "Work";
    
    // Use Car Route strategy
    Navigator app(std::make_unique&lt;CarRouteStrategy&gt;());
    app.findRoute(startLocation, endLocation);
    
    std::cout &lt;&lt; "\n";
    
    // Switch to Walking Route strategy at runtime
    app.setStrategy(std::make_unique&lt;WalkingRouteStrategy&gt;());
    app.findRoute(startLocation, endLocation);
    
    std::cout &lt;&lt; "\n";
    
    // Switch to Bike Route strategy at runtime
    app.setStrategy(std::make_unique&lt;BikeRouteStrategy&gt;());
    app.findRoute(startLocation, endLocation);

    return 0;
}</code></pre>
                    </div>
                </div>

                <!-- Real-Life Use Cases -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Real-Life Use Cases
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li><span class="font-semibold text-white">E-commerce:</span> A `PaymentProcessor` (the Context) can use different `PaymentStrategy` objects for credit card, PayPal, or crypto payments.</li>
                            <li><span class="font-semibold text-white">Data Validation:</span> A `Validator` (the Context) can use different `ValidationStrategy` objects to check for email format, password strength, or a valid date.</li>
                            <li><span class="font-semibold text-white">File Compression:</span> A `FileCompressor` (the Context) could use `ZipCompressionStrategy` or `GzipCompressionStrategy` depending on the user's choice.</li>
                        </ul>
                    </div>
                </div>

                <!-- When to Use -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        When to Use the Strategy Pattern
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <ul class="list-disc list-inside space-y-2 text-gray-300">
                            <li>When you have a class with a behavior that changes frequently or can be chosen dynamically at runtime.</li>
                            <li>When you have multiple algorithms for a single task and you want to avoid a huge `if-else` or `switch` statement in your code.</li>
                            <li>When you want to easily add new algorithms without changing the code that uses them.</li>
                        </ul>
                    </div>
                </div>

                <!-- Advantage and Disadvantage -->
                <div class="collapsible-container">
                    <div class="collapsible-header text-xl font-semibold text-white p-4 bg-gray-700 rounded-xl transition hover:bg-gray-600">
                        Advantage and Disadvantage
                    </div>
                    <div class="collapsible-content bg-gray-700 rounded-b-xl border-t border-gray-600">
                        <div class="overflow-x-auto">
                            <table class="w-full text-left table-auto border-collapse border border-gray-600 rounded-lg">
                                <thead>
                                    <tr class="bg-gray-900 text-white">
                                        <th class="p-3 border-b border-gray-600">‚úÖ Advantages</th>
                                        <th class="p-3 border-b border-gray-600">‚ùå Disadvantages</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="border-b border-gray-600">
                                        <td class="p-3">Loose Coupling: The client code is simplified because it's not tied to a specific product implementation.</td>
                                        <td class="p-3">Can introduce more classes and a more complex hierarchy.</td>
                                    </tr>
                                    <tr class="border-b border-gray-600">
                                        <td class="p-3">Encapsulation: Creation logic is centralized in one place.</td>
                                        <td class="p-3">The factory might become a "God object" if it handles too many unrelated products.</td>
                                    </tr>
                                    <tr class="border-b border-gray-600">
                                        <td class="p-3">Extensibility: Easily add new products without changing client code.</td>
                                        <td class="p-3">It can be over-engineered for very simple object creation.</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const collapsibleHeaders = document.querySelectorAll('.collapsible-header');
            collapsibleHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const isExpanded = content.classList.toggle('expanded');
                    header.classList.toggle('expanded', isExpanded);
                });
            });
        });
    </script>
</body>
</html>
